// Import Angular Classes:
import { Component, OnInit }											from '@angular/core';
import { NgClass } 														from '@angular/common';
import { Observable }     												from 'rxjs/Observable';
import { Subscriber }     												from 'rxjs/Subscriber';
import '../../utilities/rxjs-operators';

// Import Application Classes:
import { CreationStepsService }											from '../../services';
import { ValueChartService }											from '../../services';
import { UserNotificationService }										from '../../services';
import { UpdateValueChartService }										from '../../services';
import { CurrentUserService }											from '../../services';
import { ValidationService }											from '../../services';
import { ChartUndoRedoService }                     					from '../../../ValueChartVis';
import { ScoreFunctionDirective }										from '../../../ValueChartVis';
import { RendererScoreFunctionUtility }									from '../../../ValueChartVis';

// Import Model Classes:
import { ValueChart } 													from '../../../model';
import { Objective }													from '../../../model';
import { AbstractObjective }											from '../../../model';
import { PrimitiveObjective }											from '../../../model';
import { Domain }														from '../../../model';
import { CategoricalDomain }											from '../../../model';
import { ContinuousDomain }												from '../../../model';
import { IntervalDomain }												from '../../../model';
import { Alternative }													from '../../../model';
import { ScoreFunction }												from '../../../model';
import { DiscreteScoreFunction }										from '../../../model';
import { ContinuousScoreFunction }										from '../../../model';

// Import Types:
import { ChartOrientation }                         					from '../../../types';

// Import Utilities:
import *	as Formatter												from '../../utilities/Formatter';
import * as _ 															from 'lodash';

/*
	This component defines the UI controls for creating and editing the Objective structure of a ValueChart.
	It consists of an Angular table where each row is bound to an ObjectiveRow object (described at end of this file).
	Objectives are converted to/from ObjectiveRows when the component is created/destroyed.
*/

@Component({
	selector: 'CreateObjectives',
	templateUrl: './CreateObjectives.template.html',
	providers: [RendererScoreFunctionUtility]
})
export class CreateObjectivesComponent implements OnInit {

	// ========================================================================================
	// 									Fields
	// ========================================================================================

	public ChartOrientation = ChartOrientation;
	public Number = Number;
	public ScoreFunction = ScoreFunction;
	public services: any = {}; // Services container to pass to ScoreFunctionDirective

	// The ValueChart:
	valueChart: ValueChart;

	// Component state fields:
    editing: boolean; // true if the user is editing a pre-existing Objective structure, 
					  // false if this is the first time they are defining Objectives for the ValueChart

	// Objective row fields:
	objectiveRows: { [objID: string]: ObjectiveRow }; // It is necessary to track ObjectiveRows by ID since their names may not be unique
    objectivesCount: number; // Incremented every time an ObjectiveRow is added, but never decremented; used to generate unique IDs for ObjectiveRows
	selectedObjRow: string; // The ID of the row currently selected in the table
	rootObjRowID: string; // The ID of the root ObjectiveRow

	// Default color palette for Primitive Objectives (generated by ColorBrewer 2.0 for 9 categorical variables).
	defaultColors: string[] = ['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999'];

    // Add Category modal fields:
    categoryString: string = ''; // Comma-separated categories in modal textarea

    // Default Score Function modal fields:
    defaultScoreFunctionModalOpen = false;

    // Validation fields:
    validationTriggered: boolean = false; // Specifies whether or not validation has been triggered (this happens when the user attempts to navigate)
										  // If true, validation messages will be shown whenever conditions fail
	errorMessages: string[]; // Validation error messages

	// ========================================================================================
	// 									Constructor
	// ========================================================================================

	/*
		@returns {void}
		@description 	Used for Angular's dependency injection ONLY. It should not be used to do any initialization of the class.
						This constructor will be called automatically when Angular constructs an instance of this class prior to dependency injection.
	*/
	constructor(
		private currentUserService: CurrentUserService,
		private valueChartService: ValueChartService,
		private creationStepsService: CreationStepsService,
		private updateValueChartService: UpdateValueChartService,
		private validationService: ValidationService,
		private userNotificationService: UserNotificationService,
		private rendererScoreFunctionUtility: RendererScoreFunctionUtility) { }

	// ========================================================================================
	// 									Methods
	// ========================================================================================

	// ================================ Life-cycle Methods ====================================

	/* 	
		@returns {void}
		@description 	Initializes CreateObjectives. ngOnInit is only called ONCE by Angular.
						Calling ngOnInit should be left to Angular. Do not call it manually.
	*/
	ngOnInit() {
		this.creationStepsService.observables[this.creationStepsService.OBJECTIVES] = new Observable<boolean>((subscriber: Subscriber<boolean>) => {
            subscriber.next(this.validate());
            subscriber.complete();
        });
        this.services.chartUndoRedoService = new ChartUndoRedoService();
    	this.services.rendererScoreFunctionUtility = this.rendererScoreFunctionUtility;

		this.objectiveRows = {};
		this.rootObjRowID = '0';
		this.objectivesCount = 0;
		this.editing = false;
		this.errorMessages = [];
		this.valueChart = this.valueChartService.getValueChart();

		if (this.valueChart.getAllObjectives().length === 0) {
			this.objectiveRows[this.rootObjRowID] = new ObjectiveRow(this.rootObjRowID, '', this.valueChart.getName(), this.valueChart.getDescription(), '', 0, 'abstract');
			this.objectivesCount++;
		}
		else {
			this.editing = true;
			let rootObjective: Objective = this.valueChart.getRootObjectives()[0];
			this.objectiveToObjRow(rootObjective, '', 0);
			this.validate();
		}
	}

	/*   
		@returns {void}
		@description   Destroys CreateObjectives. ngOnDestroy is only called ONCE by Angular when the user navigates to a route which
		        requires that a different component is displayed in the router-outlet.
	*/
	ngOnDestroy() {
		// Convert temporary structures to ValueChart structures
		this.valueChart.setRootObjectives([this.objRowToObjective(this.objectiveRows[this.rootObjRowID])]);
		if (this.editing) {
			this.updateValueChartService.cleanUpAlternatives(this.valueChart);
			for (let user of this.valueChart.getUsers()) {
				let showWarnings = this.valueChart.isMember(this.currentUserService.getUsername()) && (this.currentUserService.getUsername() === user.getUsername());
				let warnings = this.updateValueChartService.cleanUpUserPreferences(this.valueChart, user);
				if (showWarnings) {
					this.userNotificationService.displayWarnings(warnings);
				}
			}	
		}
	}						

	// ================================ Objective Row Methods ====================================

	/* 	
		@returns {Array<string>}
		@description 	Gets all ObjectiveRow IDs.
	*/
	objKeys(): Array<string> {
		return Object.keys(this.objectiveRows);
	}

	/* 	
		@returns {void}
		@description 	Creates a new, blank ObjectiveRow under an existing ObjectiveRow.
	*/
	addNewChildObjRow(parentID: string, isGroup: boolean) {
		if (isGroup)
			this.addObjRow(parentID, new ObjectiveRow(String(this.objectivesCount), '', '', '', parentID, this.objectiveRows[parentID].depth + 1, 'abstract'));
		else
			this.addObjRow(parentID, new ObjectiveRow(String(this.objectivesCount), '', '', '', parentID, this.objectiveRows[parentID].depth + 1, 'primitive', this.getNextColor()));
		this.resetErrorMessages();
	}

	/* 	
		@returns {void}
		@description 	Inserts an ObjectiveRow under another ObjectiveRow.
	*/
	private addObjRow(parentID: string, objrow: ObjectiveRow) {
		this.objectiveRows[objrow.id] = objrow;
		this.objectivesCount++;
		if (this.objectiveRows[parentID]) {
			this.objectiveRows[parentID].addChild(objrow.id);
		}
	}

	/* 	
		@returns {void}
		@description 	Deletes the ObjectiveRow with the given ID along with its children.
	*/
	deleteObjRow(objID: string) {
		let parentID = this.objectiveRows[objID].parent;
		if (parentID !== '') {
			this.objectiveRows[parentID].removeChild(objID);
		}
		let children = this.objectiveRows[objID].children.slice();
		for (let child of children) {
			this.deleteObjRow(child);
		}
		delete this.objectiveRows[objID];
		this.resetErrorMessages();
	}

	/* 	
		@returns {void}
		@description 	Sets color of objrow based on its type.
	*/
	setColor(objrow: ObjectiveRow) {
		objrow.color = objrow.type === 'abstract' ? '' : this.getNextColor();
	}

	/* 	
		@returns {string}
		@description 	Gets next available color for objrow. Cycles through a list of defaults.
	*/
	getNextColor(): string {
		let assignedColors = this.objKeys().map(key => this.objectiveRows[key].color);
		let availableColors = this.defaultColors.filter(color => assignedColors.indexOf(color) === -1);
		while (availableColors.length === 0) { // colors will be recycled
			this.defaultColors.forEach(color => assignedColors.splice(assignedColors.indexOf(color), 1)); // remove first instance of each color
			availableColors = this.defaultColors.filter(color => assignedColors.indexOf(color) === -1);
		}
		return availableColors[0];
	}

	/* 	
		@returns {boolean}
		@description 	Disable the "Edit" button in objID's row if the domain is not valid.
	*/
	disableEditDefaultScoreFunction(objID: string): boolean {
		let objrow: ObjectiveRow = this.objectiveRows[objID];
		return this.objectiveRows[objID].type === 'abstract' || !this.objectiveRows[objID].dom.isValid();
	}

	/* 	
		@returns {void}
		@description 	Sets all default score functions to mutable if all are immutable, sets all to immutable otherwise.
	*/
	toggleAllImmutable() {
		let allImmutable = this.allImmutable();
		for (let key of this.objKeys()) {
			if (this.objectiveRows[key].type === 'primitive') {
				this.objectiveRows[key].defaultScoreFunction.immutable = !allImmutable;
			}
		}
	}

	/* 	
		@returns {boolean}
		@description 	Returns true iff all default score functions are immutable.
	*/
	allImmutable(): boolean {
		if (this.objKeys().length === 0) {
			return false;
		}
		for (let key of this.objKeys()) {
			if (this.objectiveRows[key].type === 'primitive' && !this.objectiveRows[key].defaultScoreFunction.immutable) {
				return false;
			}
		}
		return true;
	}

	/* 	
		@returns {string[]}
		@description 	Gets the ObjectiveRow IDs as a list in the order that they will be displayed.
	*/
	getFlattenedObjectiveRows(): string[] {
		let flattened: string[] = [];
		this.flattenObjectiveRows([this.rootObjRowID], flattened);
		return flattened;
	}

	/* 	
		@returns {void}
		@description 	Recursively converts the implicit tree-structure of ObjectiveRows into a list in the order that the rows will be displayed.
	*/
	flattenObjectiveRows(ObjectiveRowIDs: string[], flattened: string[]) {
		for (let objID of ObjectiveRowIDs) {
			if (objID !== '0')
				flattened.push(objID);
			this.flattenObjectiveRows(this.objectiveRows[objID].children, flattened);
		}
	}

	/* 	
		@returns {Objective}
		@description 	Converts an ObjectiveRow into an Objective.
	*/
	objRowToObjective(objrow: ObjectiveRow): Objective {
		let obj: Objective;
		if (objrow.type === 'primitive') {
			obj = this.getObjectiveById(objrow.objid);
			if (obj === undefined) {
				obj = new PrimitiveObjective('', ''); 
			}
			obj.setName(objrow.name);
			obj.setDescription(objrow.desc);
			objrow.objid = obj.getId();
			(<PrimitiveObjective>obj).setDomain(this.domainDetailsToDomain(objrow.dom));
			(<PrimitiveObjective>obj).setColor(objrow.color);
			if (!this.valueChart.isIndividual()) {
				(<PrimitiveObjective>obj).setDefaultScoreFunction(objrow.defaultScoreFunction);
			}	
		}
		else {
			obj = this.getObjectiveById(objrow.objid);
			if (obj === undefined) {
				obj = new AbstractObjective('', ''); 
			}
			obj.setName(objrow.name);
			obj.setDescription(objrow.desc);
			objrow.objid = obj.getId();
			let subObjectives: Objective[] = [];
			for (let child of objrow.children) {
				subObjectives.push(this.objRowToObjective(this.objectiveRows[child]));
			}
			(<AbstractObjective>obj).setDirectSubObjectives(subObjectives);
		}
		return obj;
	}

	getObjectiveById(id: string): Objective {
		for (let obj of this.valueChartService.getValueChart().getAllObjectives()) {
			if (obj.getId() === id) {
				return obj;
			}
		}
		return undefined;
	}

	/* 	
		@returns {Objective}
		@description 	Converts a DomainDetails object into a Domain.
	*/
	domainDetailsToDomain(domDets: DomainDetails): Domain {
		let dom: Domain;
		if (domDets.type === 'categorical') {
			dom = new CategoricalDomain(true);
			for (let cat of domDets.elements) {
				(<CategoricalDomain>dom).addElement(cat);
			}
		}
		else if (domDets.type === 'interval') {
			dom = new IntervalDomain(domDets.min, domDets.max, domDets.interval);
		}
		else {
			if (domDets.unit) {
				dom = new ContinuousDomain(domDets.min, domDets.max, domDets.unit);
			}
			else {
				dom = new ContinuousDomain(domDets.min, domDets.max);
			}				
		}
		return dom;
	}

	/* 	
		@returns {void}
		@description 	Recursively converts an Objective and all its descendants into ObjectiveRows.
	*/
	objectiveToObjRow(obj: Objective, parentID: string, depth: number) {
		let objrow: ObjectiveRow;
		if (obj.objectiveType === 'abstract') {
			objrow = new ObjectiveRow(String(this.objectivesCount), obj.getId(), obj.getName(), obj.getDescription(), parentID, depth, 'abstract');
			this.addObjRow(parentID, objrow);
			for (let child of (<AbstractObjective>obj).getDirectSubObjectives()) {
				this.objectiveToObjRow(child, objrow.id, objrow.depth + 1);
			}
		}
		else {
			objrow = new ObjectiveRow(String(this.objectivesCount), obj.getId(), obj.getName(), obj.getDescription(), parentID, depth, 'primitive', (<PrimitiveObjective>obj).getColor(),
				this.domainToDomainDetails((<PrimitiveObjective>obj).getDomain()), (<PrimitiveObjective>obj).getDefaultScoreFunction());
			objrow.latestDefault = this.getClosestDefault(<PrimitiveObjective>obj);
			this.addObjRow(parentID, objrow);
		}
	}

	/* 	
		@returns {DomainDetails}
		@description 	Converts an Objective's Domain into DomainDetails (internal representation).
	*/
	domainToDomainDetails(dom: Domain): DomainDetails {
		let domDets: DomainDetails = new DomainDetails(dom.type);
		if (dom.type === 'categorical') {
			for (let cat of (<CategoricalDomain>dom).getElements()) {
				domDets.elements.push(cat);
			}
		}
		else if (dom.type === 'continuous') {
			domDets.min = (<ContinuousDomain>dom).getMinValue();
			domDets.max = (<ContinuousDomain>dom).getMaxValue();
			domDets.unit = (<ContinuousDomain>dom).unit;
		}
		else {
			domDets.min = (<IntervalDomain>dom).getMinValue();
			domDets.max = (<IntervalDomain>dom).getMaxValue();
			domDets.interval = (<IntervalDomain>dom).getInterval();
			domDets.initializeIntervalDomainElements();
		}
		return domDets;
	}

	/* 	
		@returns {string}
		@description 	Returns the type of default (flat, positive linear, or negative linear) that is most similar to the current default score function.
	*/
	getClosestDefault(obj: PrimitiveObjective): string {
		let flatDiff = this.getDifference(obj.getInitialScoreFunction(ScoreFunction.FLAT), obj.getDefaultScoreFunction());
		let poslinDiff = this.getDifference(obj.getInitialScoreFunction(ScoreFunction.POSLIN), obj.getDefaultScoreFunction());
		let neglinDiff = this.getDifference(obj.getInitialScoreFunction(ScoreFunction.NEGLIN), obj.getDefaultScoreFunction());
		if (flatDiff <= poslinDiff && flatDiff <= neglinDiff) {
			return ScoreFunction.FLAT;
		}
		else {
			return poslinDiff <= neglinDiff ? ScoreFunction.POSLIN : ScoreFunction.NEGLIN;
		}
	}

	/* 	
		@returns {number}
		@description 	Returns the sum of the absolute difference between the element scores of two score functions.
						(Assumes the score function elements are the same.)
	*/
	getDifference(funcA: ScoreFunction, funcB: ScoreFunction) {
		if (!_.isEqual(funcA.getAllElements(), funcB.getAllElements())) {
			throw "Score function elements are not the same.";
		}
		let diff = 0;
		for (let elt of funcA.getAllElements()) {
			diff = diff + Math.abs(funcA.getScore(elt) - funcB.getScore(elt));
		}
		return diff;
	}

	// ================================ Categorical Domain Methods ====================================


	/* 	
		@returns {void}
		@description 	Updates categoryString to contain the categories for the selected Objective Row.
	*/
	updateCategoryString() {
		this.categoryString = this.objectiveRows[this.selectedObjRow].dom.elements.join(', ');
	}

	/* 	
		@returns {void}
		@description 	Updates the categories for the selected Objective Row based on the categoryString.
	*/
	updateCategories() {
		let editing = this.objectiveRows[this.selectedObjRow].dom.isValid();
		let categories = this.categoryString.split(',').map(cat => cat.trim());
		let uniqueCategories = categories.filter(function(elem, index, self) { return index === self.indexOf(elem); });
		this.objectiveRows[this.selectedObjRow].dom.elements = uniqueCategories;

		if (editing)
			this.updateCategoricalDefaultScoreFunction();
		else
			this.objectiveRows[this.selectedObjRow].initializeDefaultScoreFunction(false);

		this.resetErrorMessages();
	}

	/*
		@returns {void}
		@description 	Updates the default score function elements to reflect the domain elements for the selected Objective Row.
	*/
	updateCategoricalDefaultScoreFunction() {
		let elementScoreMap = new Map<number | string, number>();
		let elements = this.objectiveRows[this.selectedObjRow].dom.elements;
		let defaultScoreFunction = this.objectiveRows[this.selectedObjRow].defaultScoreFunction;
        for (let elt of elements) {
        	if (defaultScoreFunction.getScore(elt) === undefined) {
				elementScoreMap.set(elt, 0.5);
				this.objectiveRows[this.selectedObjRow].defaultScoreFunctionModified = true;
			}
			else {
				elementScoreMap.set(elt, defaultScoreFunction.getScore(elt));
			}	
        }
        defaultScoreFunction.setElementScoreMap(elementScoreMap);
	}

	/* 	
		@returns {string[]}
		@description 	Gets selected elements of a given HTMLSelectElement.
	*/
	getSelectedValues(select: HTMLSelectElement): string[] {
		let result: string[] = [];
		let options: HTMLCollection = select && select.options;
		let opt: HTMLOptionElement;

		for (let i = 0, iLen = options.length; i < iLen; i++) {
			opt = <HTMLOptionElement>options[i];
			if (opt.selected) {
				result.push(opt.value || opt.text);
			}
		}
		return result;
	}

	// ================================ Validation Methods ====================================

	/* 	
		@returns {boolean}
		@description 	Checks validity of objectives structure in the chart.
	*/
	validate(): boolean {
		this.validationTriggered = true;
		this.setErrorMessages();

		// Clean up references to Objectives
		this.updateValueChartService.cleanUpAlternatives(this.valueChart);
		for (let user of this.valueChart.getUsers()) {
			let showWarnings = this.valueChart.isMember(this.currentUserService.getUsername()) && (this.currentUserService.getUsername() === user.getUsername());
			let warnings = this.updateValueChartService.cleanUpUserPreferences(this.valueChart, user);
			if (showWarnings) {
				this.userNotificationService.displayWarnings(warnings);
			}
		}
		
		return this.errorMessages.length === 0;
	}

	/* 	
		@returns {boolean}
		@description 	Converts ObjectiveRow structure into ValueChart objective, then validates the objective structure of the ValueChart.
	*/
	setErrorMessages(): void {
		// Convert temporary structures to ValueChart structures
		this.valueChart.setRootObjectives([this.objRowToObjective(this.objectiveRows[this.rootObjRowID])]);

		// Validate
		this.errorMessages = this.validationService.validateObjectives(this.valueChart);
	}

	/* 	
		@returns {void}
		@description 	Resets error messages if validation has already been triggered.
						(This is done whenever the user makes a change to the chart. This way, they get feedback while repairing errors.)
	*/
	resetErrorMessages(): void {
		if (this.validationTriggered) {
			this.setErrorMessages();
		}
	}
}

/*
	This is an internal structure that is used to store the details of each Objective in the html table.
	Objectives are converted to/from ObjectiveRows when the component is created/destroyed.
	This is done so that ObjectiveRows can be converted between types while keeping the same object.
	It also allows us to store other useful properties (e.g. parent, depth) and makes Angular field binding simpler.
*/
class ObjectiveRow {
	id: string;
	objid: string; // the id of the corresponding objective object (if it exists)
	name: string;
	desc: string;
	parent: string;
	depth: number;
	type: string;
	color: string;
	dom: DomainDetails;
	children: string[];
	defaultScoreFunction: ScoreFunction;
	latestDefault: string; // Track latest selection in default dropdown
	defaultScoreFunctionModified: boolean; // True iff the default score function for objID has been programmatically changed since the user last inspected it

	constructor(id: string, objid: string, name: string, desc: string, parent: string, depth: number, type?: string, color?: string, dom?: DomainDetails, defaultScoreFunction?: ScoreFunction) {
		this.id = id;
		this.objid = objid;
		this.name = name;
		this.desc = desc;
		this.parent = parent;
		this.depth = depth;
		this.type = type;
		color ? this.color = color : this.color = '';
		dom ? this.dom = dom : this.dom = new DomainDetails('categorical');
		this.children = [];
		this.latestDefault = ScoreFunction.FLAT;
		this.defaultScoreFunctionModified = false;
		defaultScoreFunction ? this.defaultScoreFunction = defaultScoreFunction : this.constructDefaultScoreFunction();
	}

	addChild(child: string) {
		this.children.push(child);
	}

	removeChild(child: string) {
		let i = this.children.indexOf(child);
        this.children.splice(i, 1);
	}

	changeDomType(newType: string) {
		let oldType = this.dom.type;
		this.dom.type = newType;
		if (!(oldType === 'interval' && this.dom.type === 'categorical')) {
			this.constructDefaultScoreFunction();
		}
	}

	constructDefaultScoreFunction() {
		let scoreFunction;
		if (this.dom.type === 'categorical' || this.dom.type === 'interval') {
			scoreFunction = new DiscreteScoreFunction();
		}
		else {
			scoreFunction = new ContinuousScoreFunction(this.dom.min, this.dom.max);
		}
		this.defaultScoreFunction = scoreFunction;
		this.initializeDefaultScoreFunction(false);
	}

	initializeDefaultScoreFunction(userTriggered: boolean) {
		if (this.dom.type === 'categorical') {
			(<DiscreteScoreFunction>this.defaultScoreFunction).initialize(this.latestDefault, this.dom.elements);
		}
		else if (this.dom.type === 'interval') {
			this.dom.initializeIntervalDomainElements();
			(<DiscreteScoreFunction>this.defaultScoreFunction).initialize(this.latestDefault, this.dom.elements);
		}
		else {
			(<ContinuousScoreFunction>this.defaultScoreFunction).setMinDomainValue(this.dom.min);
			(<ContinuousScoreFunction>this.defaultScoreFunction).setMaxDomainValue(this.dom.max);
			(<ContinuousScoreFunction>this.defaultScoreFunction).initialize(this.latestDefault);
		}
		if (!userTriggered) {
			this.defaultScoreFunctionModified = true;
		}		
	}

	copy(): ObjectiveRow {
		let domCopy = this.dom.copy();
		return new ObjectiveRow(this.id, this.objid, this.name, this.desc, this.parent, this.depth, this.type, this.color, domCopy, this.defaultScoreFunction);
	}
}

/*
	This class stores the details of an ObjectiveRow's domain.
	A single class covers all possible types so that ObjectiveRows can be converted between types while keeping the same object.
*/
class DomainDetails {
	type: string;
	elements: string[];
	min: number;
	max: number;
	interval: number;
	unit: string;

	constructor(type: string) {
		this.type = type;
		this.elements = [];
	}

	removeElement(cat: string) {
		let i = this.elements.indexOf(cat);
        this.elements.splice(i, 1);
	}

	initializeIntervalDomainElements() {
		this.elements = [];
		if (this.interval > 0) {
			let currentElement: number = this.min;
			while (currentElement < this.max) {
				this.elements.push('' + currentElement);
				currentElement += this.interval;
			}
			this.elements.push('' + this.max);
		}
	}

	isValid(): boolean {
		if (this.type === 'categorical') {
			return this.elements.length > 1;
		}
		else if (this.min !== undefined && !isNaN(this.min) && this.max !== undefined && !isNaN(this.max) && this.min < this.max) {
			return (this.type === 'continuous' || (this.interval > 0 && (this.max - this.min) % this.interval === 0));
		}
		return false;
	}

	copy(): DomainDetails {
		let domCopy = new DomainDetails(this.type);
		domCopy.elements = this.elements.slice();
		domCopy.min = this.min;
		domCopy.max = this.max;
		domCopy.interval = this.interval;
		domCopy.unit = this.unit;
		return domCopy;
	}
}